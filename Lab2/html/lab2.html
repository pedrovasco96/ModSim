
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>lab2</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-04-24"><meta name="DC.source" content="lab2.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">2.</a></li><li><a href="#3">3.</a></li><li><a href="#6">7.</a></li><li><a href="#15">8.</a></li><li><a href="#21">9.</a></li><li><a href="#23">10.</a></li><li><a href="#25">11.</a></li><li><a href="#29">12.</a></li><li><a href="#32">13.</a></li></ul></div><pre>             2 Laboratorio de Modelacao e Simulacao
                      2Semestre - 2016/2017
Luis Almeida, n 81232
Pedro Vasco, n 81880
Grupo 11 Turno 2 feira 10h</pre><pre class="codeinput">clear <span class="string">all</span>;
close <span class="string">all</span>;
clc;
</pre><h2>2.<a name="2"></a></h2><pre class="codeinput"><span class="comment">% Definicao do intervalo de tempo e constante beta</span>
t=-1:0.01:1;
beta=0.3;

<span class="comment">% Geracao do impulso</span>
pbeta=impulso(t,beta);

figure();
plot(t,pbeta);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'p_{\beta}'</span>);
title(<span class="string">'Impulso (\beta=0.3)'</span>);

beta=0;

<span class="comment">% Geracao do impulso</span>
pbeta=impulso(t,beta);

figure();
plot(t,pbeta);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'p_{\beta}'</span>);
title(<span class="string">'Impulso (\beta=0)'</span>);

beta=1;

<span class="comment">% Geracao do impulso</span>
pbeta=impulso(t,beta);

figure();
plot(t,pbeta);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'p_{\beta}'</span>);
title(<span class="string">'Impulso (\beta=1)'</span>);
</pre><img vspace="5" hspace="5" src="lab2_01.png" alt=""> <img vspace="5" hspace="5" src="lab2_02.png" alt=""> <img vspace="5" hspace="5" src="lab2_03.png" alt=""> <h2>3.<a name="3"></a></h2><pre class="codeinput"><span class="comment">% Definicao das constantes para construcao do sinal de controlo u(t)</span>
U1=1;
U2=1;
T=1;
alfa=1.5;
beta=0.2;
n1=100;
n2=100;

<span class="comment">% Construcao do sinal</span>
[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

figure();
plot(t,u);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'u(t)'</span>);
title(<span class="string">'Sinal'</span>);
</pre><img vspace="5" hspace="5" src="lab2_04.png" alt=""> <p>Definicao das constantes para construcao do sinal de controlo u(t)</p><pre class="codeinput">U1=1;
U2=1;
T=4;
alfa=2.5;
n1=100;
n2=100;

<span class="comment">% Construcao do sinal</span>
[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

figure();
plot(t,u);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'u(t)'</span>);
title(<span class="string">'Sinal'</span>);
</pre><img vspace="5" hspace="5" src="lab2_05.png" alt=""> <p>Definicao das constantes para construcao do sinal de controlo u(t)</p><pre class="codeinput">U1=1;
U2=2;
T=1;
alfa=0.5;
n1=100;
n2=100;

<span class="comment">% Construcao do sinal</span>
[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

figure();
plot(t,u);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'u(t)'</span>);
title(<span class="string">'Sinal'</span>);
</pre><img vspace="5" hspace="5" src="lab2_06.png" alt=""> <h2>7.<a name="6"></a></h2><pre class="codeinput">clear <span class="string">all</span>;
close <span class="string">all</span>;
clc;

b=0;

<span class="comment">% Caso de alfa=0.5 e beta=0.2</span>
alfa=0.5;
beta=0.2;

<span class="comment">% Calculo de T e U1 segundo as formulas determinadas teoricamente</span>
T=sqrt(2*(1+beta)*(1+alfa)/alfa);
T1=T/(1+alfa);

U1=(2*(1+beta))/(((T1)^2)*(alfa+1));
U2=U1/alfa;

<span class="comment">% Numero de pontos</span>
n1=200;
n2=200;

[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

np=n1+n2-1;

step=T/np;

u_entrada.time=[t'];
u_entrada.signals.values=[u'];
u_entrada.signals.dimensions=[1];
sim(<span class="string">'sim1'</span>,t);

tsim1=tsim;
y1=y;
yponto1=yponto;
</pre><p>Caso de alfa=1 e beta=0.2</p><pre class="codeinput">alfa=1;
beta=0.2;

<span class="comment">% Calculo de T e U1 segundo as formulas determinadas teoricamente</span>
T=sqrt(2*(1+beta)*(1+alfa)/alfa);
T1=T/(1+alfa);

U1=(2*(1+beta))/(((T1)^2)*(alfa+1));
U2=U1/alfa;

[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

u_entrada.time=[t'];
u_entrada.signals.values=[u'];
u_entrada.signals.dimensions=[1];
sim(<span class="string">'sim1'</span>,t);

tsim2=tsim;
y2=y;
yponto2=yponto;
</pre><p>Caso de alfa=1.3 e beta=0.4</p><pre class="codeinput">alfa=1.3;
beta=0.4;

<span class="comment">% Calculo de T e U1 segundo as formulas determinadas teoricamente</span>
T=sqrt(2*(1+beta)*(1+alfa)/alfa);
T1=T/(1+alfa);

U1=(2*(1+beta))/(((T1)^2)*(alfa+1));
U2=U1/alfa;

[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

u_entrada.time=[t'];
u_entrada.signals.values=[u'];
u_entrada.signals.dimensions=[1];
sim(<span class="string">'sim1'</span>,t);

tsim3=tsim;
y3=y;
yponto3=yponto;
</pre><p>Desenho dos graficos</p><pre class="codeinput"><span class="comment">% Evolucao da posicao</span>
figure();
plot(tsim1,y1,<span class="string">'r'</span>);
grid <span class="string">on</span>;
hold <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'y(t)'</span>);
title(<span class="string">'Posicao do braco'</span>);
plot(tsim2,y2,<span class="string">'m'</span>);
plot(tsim3,y3,<span class="string">'b'</span>);
hold <span class="string">off</span>;
legend(<span class="string">'alfa=0.5 e beta=0.2'</span>,<span class="string">'alfa=1 e beta=0.2'</span>,<span class="string">'alfa=1.3 e beta=0.4'</span>);

<span class="comment">% Evolucao da velocidade</span>
figure();
plot(tsim1, yponto1,<span class="string">'r'</span>);
grid <span class="string">on</span>;
hold <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'$$\dot{y} (t)$$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Velocidade do braco'</span>);
plot(tsim2, yponto2,<span class="string">'m'</span>);
plot(tsim3, yponto3,<span class="string">'b'</span>);
hold <span class="string">off</span>;
legend(<span class="string">'alfa=0.5 e beta=0.2'</span>,<span class="string">'alfa=1 e beta=0.2'</span>,<span class="string">'alfa=1.3 e beta=0.4'</span>);

<span class="comment">% Plano (posicao,velocidade)</span>
figure();
plot(y1,yponto1,<span class="string">'r'</span>);
grid <span class="string">on</span>;
hold <span class="string">on</span>;
xlabel(<span class="string">'y'</span>);
ylabel(<span class="string">'$$\dot{y} (t)$$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Plano (y, $$\dot{y}$$)'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
plot(y2,yponto2,<span class="string">'m'</span>);
plot(y3,yponto3,<span class="string">'b'</span>);
hold <span class="string">off</span>;
legend(<span class="string">'alfa=0.5 e beta=0.2'</span>,<span class="string">'alfa=1 e beta=0.2'</span>,<span class="string">'alfa=1.3 e beta=0.4'</span>);
</pre><img vspace="5" hspace="5" src="lab2_07.png" alt=""> <img vspace="5" hspace="5" src="lab2_08.png" alt=""> <img vspace="5" hspace="5" src="lab2_09.png" alt=""> <p>Versao perturbada</p><pre class="codeinput">b=0.025;

<span class="comment">% Caso de alfa=0.5 e beta=0.2</span>
alfa=0.5;
beta=0.2;

<span class="comment">% Calculo de T e U1 segundo as formulas determinadas teoricamente</span>
T=sqrt(2*(1+beta)*(1+alfa)/alfa);
T1=T/(1+alfa);

U1=(2*(1+beta))/(((T1)^2)*(alfa+1));
U2=U1/alfa;

[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

np=n1+n2-1;

step=T/np;

u_entrada.time=[t'];
u_entrada.signals.values=[u'];
u_entrada.signals.dimensions=[1];

sim(<span class="string">'sim1'</span>,t);

tsim1=tsim;
y1=y;
yponto1=yponto;
</pre><p>Caso de alfa=1 e beta=0.2</p><pre class="codeinput">alfa=1;
beta=0.2;

<span class="comment">% Calculo de T e U1 segundo as formulas determinadas teoricamente</span>
T=sqrt(2*(1+beta)*(1+alfa)/alfa);
T1=T/(1+alfa);

U1=(2*(1+beta))/(((T1)^2)*(alfa+1));
U2=U1/alfa;

[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

u_entrada.time=[t'];
u_entrada.signals.values=[u'];
u_entrada.signals.dimensions=[1];
sim(<span class="string">'sim1'</span>,t);

tsim2=tsim;
y2=y;
yponto2=yponto;
</pre><p>Caso de alfa=1.3 e beta=0.4</p><pre class="codeinput">alfa=1.3;
beta=0.4;

<span class="comment">% Calculo de T e U1 segundo as formulas determinadas teoricamente</span>
T=sqrt(2*(1+beta)*(1+alfa)/alfa);
T1=T/(1+alfa);

U1=(2*(1+beta))/(((T1)^2)*(alfa+1));
U2=U1/alfa;

[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

u_entrada.time=[t'];
u_entrada.signals.values=[u'];
u_entrada.signals.dimensions=[1];

sim(<span class="string">'sim1'</span>,t);

tsim3=tsim;
y3=y;
yponto3=yponto;
</pre><p>Desenho dos graficos</p><pre class="codeinput"><span class="comment">% Evolucao da posicao</span>
figure();
plot(tsim1,y1,<span class="string">'r'</span>);
grid <span class="string">on</span>;
hold <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'y(t)'</span>);
title(<span class="string">'Posicao do braco'</span>);
plot(tsim2,y2,<span class="string">'m'</span>);
plot(tsim3,y3,<span class="string">'b'</span>);
hold <span class="string">off</span>;
legend(<span class="string">'alfa=0.5 e beta=0.2'</span>,<span class="string">'alfa=1 e beta=0.2'</span>,<span class="string">'alfa=1.3 e beta=0.4'</span>);

<span class="comment">% Evolucao da velocidade</span>
figure();
plot(tsim1, yponto1,<span class="string">'r'</span>);
grid <span class="string">on</span>;
hold <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'$$\dot{y} (t)$$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Velocidade do braco'</span>);
plot(tsim2, yponto2,<span class="string">'m'</span>);
plot(tsim3, yponto3,<span class="string">'b'</span>);
hold <span class="string">off</span>;
legend(<span class="string">'alfa=0.5 e beta=0.2'</span>,<span class="string">'alfa=1 e beta=0.2'</span>,<span class="string">'alfa=1.3 e beta=0.4'</span>);

<span class="comment">% Plano (posicao,velocidade)</span>
figure();
plot(y1,yponto1,<span class="string">'r'</span>);
grid <span class="string">on</span>;
hold <span class="string">on</span>;
xlabel(<span class="string">'y'</span>);
ylabel(<span class="string">'$$\dot{y} (t)$$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Plano (y, $$\dot{y}$$)'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
plot(y2,yponto2,<span class="string">'m'</span>);
plot(y3,yponto3,<span class="string">'b'</span>);
hold <span class="string">off</span>;
legend(<span class="string">'alfa=0.5 e beta=0.2'</span>,<span class="string">'alfa=1 e beta=0.2'</span>,<span class="string">'alfa=1.3 e beta=0.4'</span>);
</pre><img vspace="5" hspace="5" src="lab2_10.png" alt=""> <img vspace="5" hspace="5" src="lab2_11.png" alt=""> <img vspace="5" hspace="5" src="lab2_12.png" alt=""> <p>Tal como previsto teoricamente, a situacao em que a cabeca se desloca mais rapidamente para o valor 0 corresponde ao caso em que temos <img src="lab2_eq01505123926026738633.png" alt="$\alpha=1$">. Verificamos que para valores de alfa e beta aleatorios obtiveram-se os valores finais desejados. Por outro lado, quando adicionamos um valor b diferente de zero, correspondente a existencia de atrito, verificamos que a cabeca nao se desloca exatamente para a posicao zero ficando ainda alguma distancia. Isto deve-se ao fato de estarmos a produzir uma tensao que leva a cabeca para zero sem atrito. No caso de b diferente de zero teriamos que ter em conta a forca aplicada necessaria para vencer a forca de atrito.</p><h2>8.<a name="15"></a></h2><pre class="codeinput">clear <span class="string">all</span>;
close <span class="string">all</span>;
clc;

<span class="comment">% Grelha de pontos</span>
y=[-1:0.05:1];
yponto=[-1:0.05:1];
count=length(yponto);

<span class="keyword">for</span> i=1:1:count
	<span class="keyword">for</span> j=1:1:count
		ut(i,j)=sign(sign(-y(i))*sqrt(2*abs(-y(i)))-yponto(j));
	<span class="keyword">end</span>
<span class="keyword">end</span>

figure();
surf(y,yponto,ut);
view(-140, 34);
xlabel(<span class="string">'yponto'</span>);
ylabel(<span class="string">'y'</span>);
zlabel(<span class="string">'u'</span>);
</pre><img vspace="5" hspace="5" src="lab2_13.png" alt=""> <p>Este tipo de funcionamento tem um objetivo semelhante ao anterior, com a diferenca de u(t) ser gerado dinamicamente em funcao dos valores de posicao e velocidade em dado instante de tempo. Para cada par (y,v) e gerado um valor u de modo a que o sistema se comporte como desejado.</p><p>No caso de b=0, a tensao u ira corresponder a aceleracao. Quando temos posicao positiva e velocidade positiva a tensao tera que ser negativa de modo a colocar a velocidade negativa levando a cabeca para 0.</p><p>Quando a posicao e negativa e a velocidade negativa, u tera que ser positiva de modo a colocar a velocidade no sentido positivo levando a cabeca para zero.</p><p>Se a posicao for positiva e a velocidade negativa, quando os valores de posicao forem proximos de 1 a tensao vai ser negativa de modo a aumentar em modulo a velocidade negativa de modo a deslocar a cabeca mais rapidamente para zero, enquanto que para valores de posicao proximos de zero a tensao e positiva diminuindo o modulo da velocidade negativa de modo a colocar a cabeca na posicao zero com velocidade nula.</p><p>Se a posicao for negativa e a velocidade positiva acontece exatamente o referido na situacao anterior mas com valores simetricos.</p><h2>9.<a name="21"></a></h2><pre class="codeinput">clear <span class="string">all</span>;
close <span class="string">all</span>;
clc;

<span class="comment">% Definicao de condicoes iniciais</span>
yinicial=1;
ypinicial=0;

sim(<span class="string">'sim9'</span>);

figure();
plot(tsim,y);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'Posicao'</span>);

figure();
plot(tsim,v);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'v'</span>);
title(<span class="string">'Velocidade'</span>);

figure();
plot(tsim,utensao);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'u'</span>);
title(<span class="string">'Tensao'</span>);
</pre><img vspace="5" hspace="5" src="lab2_14.png" alt=""> <img vspace="5" hspace="5" src="lab2_15.png" alt=""> <img vspace="5" hspace="5" src="lab2_16.png" alt=""> <p>Em primeiro lugar, podemos verificar que esta estrategia permite chegar ao obejetivo pretendido (cabeca na posicao 0 com velocidade 0). Inclusive, esta metodologia leva a cabeca para a origem mais rapidamente que os outros metodos logo permite cumprir o objetivo com maior eficiencia. No entanto, se observarmos o sinal de controlo (u) verificamos que apos o sistema atingir o equilibrio (y=0 e v=0), o sinal de controlo comeca a oscilar rapidamente em torno de 0 entre -1 e 1. Este fenomeno consiste no denominado chattering, fenomeno este que sera prejudicial para o disco vai desgastar a cabeca do braco do disco. O ideal depois do equilibrio seria termos um sinal u constante e igual a 0. Este fenomeno deve-se aos pequenos ajustes que a cabeca faz em torno da origem fruto de o sistema ser realimentado. Em particular, o problema esta no declive elevado do ganho de saturacao junto a origem.</p><h2>10.<a name="23"></a></h2><pre class="codeinput">clear <span class="string">all</span>;
close <span class="string">all</span>;
clc;

<span class="comment">% Definicao de constantes</span>
yl=0.05;

k1=1/yl;
k2=sqrt(2*k1);

<span class="comment">% Grelha de valores</span>
y=[-1:0.02:1];
yponto=[-1:0.02:1];
count=length(yponto);

<span class="keyword">for</span> i=1:1:count
	<span class="keyword">for</span> j=1:1:count
		<span class="keyword">if</span>(abs(y(i))&lt;=yl)
			ut(i,j)=sign((k1/k2)*(-y(i))-yponto(j));
		<span class="keyword">end</span>
		<span class="keyword">if</span>(abs(y(i))&gt;=yl)
			ut(i,j)=sign(sign(-y(i))*(sqrt(2*abs(-y(i)))-(1/k2))-yponto(j));
		<span class="keyword">end</span>
	<span class="keyword">end</span>
<span class="keyword">end</span>

figure();
surf(y,yponto,ut);
view(-140, 34);
xlabel(<span class="string">'$$\dot{y} (t)$$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
ylabel(<span class="string">'y'</span>);
zlabel(<span class="string">'u'</span>);
</pre><img vspace="5" hspace="5" src="lab2_17.png" alt=""> <p>De modo a ultrapassar o problema de chattering encontrado no sistema anterior, a funcao e que rege o sistema e agora alterada de modo a tornar o declive que antes era excessivamente elevado em algo mais "suave". Olhando para a superficie 3D que relaciona posicao, velociade e tensao contata-se que e praticamente igual a obtida na pergunta 8. No entanto, neste grafico 3D podemos ver uma transicao muito mais suave entre os valores -1 e 1 de u, o que indica uma maior linearidade em torno da origem que permite eliminar o chattering. Quanto maior for k1 mais suave sera o sistema.</p><h2>11.<a name="25"></a></h2><pre class="codeinput">clear <span class="string">all</span>;
close <span class="string">all</span>;
clc;

<span class="comment">% Definicao de constantes</span>
yl=0.05;

k1=1/yl;
k2=sqrt(2*k1);

sim(<span class="string">'sim11a'</span>);

figure();
plot(tsim,y);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'Posicao'</span>);

figure();
plot(tsim,v);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'v'</span>);
title(<span class="string">'Velocidade'</span>);

figure();
plot(tsim,utensao);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'u'</span>);
title(<span class="string">'Tensao'</span>);
</pre><img vspace="5" hspace="5" src="lab2_18.png" alt=""> <img vspace="5" hspace="5" src="lab2_19.png" alt=""> <img vspace="5" hspace="5" src="lab2_20.png" alt=""> <p>Fazendo o ganho anterior igual a k2 e mudando a funcao utilizada no sistema conseguimos eliminar o efeito de chattering. Com este novo metodo, apos a velocidade e posicao chegarem a zero, a tensao u vai-se aproximando tambem de zero deixando de ter o efeito oscilante do anterior metodo. No entanto, apesar de termos corrigido este efeito o sistema torna-se mais lento sendo que a posicao chega a zero em aproximadamente 3 segundos ao contrario do anterior metodo em que demorava menos de 2 segundos. A degradacao no tempo sera 2.967-1.929=1.038s.</p><p>Utilizando apenas o ramo (k1/k2)*x</p><pre class="codeinput">sim(<span class="string">'sim11b'</span>);

figure();
plot(tsim,y);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'Posicao'</span>);

figure();
plot(tsim,v);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'v'</span>);
title(<span class="string">'Velocidade'</span>);

figure();
plot(tsim,utensao);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'u'</span>);
title(<span class="string">'Tensao'</span>);
</pre><img vspace="5" hspace="5" src="lab2_21.png" alt=""> <img vspace="5" hspace="5" src="lab2_22.png" alt=""> <img vspace="5" hspace="5" src="lab2_23.png" alt=""> <p>Usando apenas o primeiro ramo da funcao todos os tres parametros tendem para zero (nao ha efeito de chattering) mas para alem de serem mais lentos a convergir para zero a posicao e a velocidade oscilam um pouco em torno de zero ate que convirjam para este valor.</p><h2>12.<a name="29"></a></h2><pre class="codeinput">clear <span class="string">all</span>;
close <span class="string">all</span>;
clc;

<span class="comment">% Metodo 1</span>

<span class="comment">% Definicao de condicoes iniciais</span>
yinicial=1;
ypinicial=0;
b=0.025;

sim(<span class="string">'sim12a'</span>);

figure();
plot(tsim,y);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'Posicao'</span>);

figure();
plot(tsim,v);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'v'</span>);
title(<span class="string">'Velocidade'</span>);

figure();
plot(tsim,utensao);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'u'</span>);
title(<span class="string">'Tensao'</span>);
</pre><img vspace="5" hspace="5" src="lab2_24.png" alt=""> <img vspace="5" hspace="5" src="lab2_25.png" alt=""> <img vspace="5" hspace="5" src="lab2_26.png" alt=""> <p>Metodo 2</p><pre class="codeinput"><span class="comment">% Definicao de constantes</span>
yl=0.05;

k1=1/yl;
k2=sqrt(2*k1);

sim(<span class="string">'sim12b'</span>);

figure();
plot(tsim,y);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'Posicao'</span>);

figure();
plot(tsim,v);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'v'</span>);
title(<span class="string">'Velocidade'</span>);

figure();
plot(tsim,utensao);
grid <span class="string">on</span>;
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'u'</span>);
title(<span class="string">'Tensao'</span>);
</pre><img vspace="5" hspace="5" src="lab2_27.png" alt=""> <img vspace="5" hspace="5" src="lab2_28.png" alt=""> <img vspace="5" hspace="5" src="lab2_29.png" alt=""> <p>Dado a estarmos perante um sistema em cadeia fechada, as perturbacoes causadas pelo atrito nao tem influencia no resulatdo final. Adicionando b obtemos as mesmas respostas que obtivemos com b=0</p><h2>13.<a name="32"></a></h2><pre class="codeinput"><span class="comment">% Definicao de constantes</span>
b=0;
yl=0.05;
k1=1/yl;
k2=sqrt(2*k1);

<span class="comment">% Referencia de sinais rampa</span>
figure();
sim(<span class="string">'sim13'</span>);
plot(tsim, y, tsim, referencia,<span class="string">'LineWidth'</span>, 1);
xlabel(<span class="string">'Tempo'</span>);
ylabel(<span class="string">'Posicao y'</span>);
title(<span class="string">'Posicao y para o sinal de referencia composto por rampas'</span>);
legend(<span class="string">'Posicao y'</span>,<span class="string">'Referencia'</span>);

<span class="comment">% Referencia de sinais constantes</span>
figure();
sim(<span class="string">'sim13b'</span>);
plot(tsim, y, tsim, referencia,<span class="string">'LineWidth'</span>, 1);
xlabel(<span class="string">'Tempo'</span>);
ylabel(<span class="string">'Posicao y'</span>);
title(<span class="string">'Posicao y para o sinal de referencia composta por degraus'</span>);
legend(<span class="string">'Posicao y'</span>,<span class="string">'Referencia'</span>);
</pre><img vspace="5" hspace="5" src="lab2_30.png" alt=""> <img vspace="5" hspace="5" src="lab2_31.png" alt=""> <p>Espera-se que alterando o valor de referencia, o sistema tambem tenda para esse valor. Analisando os graficos consegue se ver que a posicao do braco segue o valor de referencia apenas com um atraso no tempo, o mesmo iria acontecer com um sinal de referencia composta por degraus mas por impossibilidade fisica a posicao nao pode ter descontinuidades espaciais, portanto a posicao y vai ajustar-se ao longo do tempo para o novo valor de referencia</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%%
%               2 Laboratorio de Modelacao e Simulacao                   
%                        2Semestre - 2016/2017                                                                                                 
% Luis Almeida, n 81232                                                  
% Pedro Vasco, n 81880                                                   
% Grupo 11 Turno 2 feira 10h      

clear all;
close all;
clc;

%% 2.

% Definicao do intervalo de tempo e constante beta
t=-1:0.01:1;
beta=0.3;

% Geracao do impulso
pbeta=impulso(t,beta);

figure();
plot(t,pbeta);
grid on;
xlabel('t');
ylabel('p_{\beta}');
title('Impulso (\beta=0.3)');

beta=0;

% Geracao do impulso
pbeta=impulso(t,beta);

figure();
plot(t,pbeta);
grid on;
xlabel('t');
ylabel('p_{\beta}');
title('Impulso (\beta=0)');

beta=1;

% Geracao do impulso
pbeta=impulso(t,beta);

figure();
plot(t,pbeta);
grid on;
xlabel('t');
ylabel('p_{\beta}');
title('Impulso (\beta=1)');

%% 3.

% Definicao das constantes para construcao do sinal de controlo u(t)
U1=1;
U2=1;
T=1;
alfa=1.5;
beta=0.2;
n1=100;
n2=100;

% Construcao do sinal
[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

figure();
plot(t,u);
grid on;
xlabel('t');
ylabel('u(t)');
title('Sinal');

%%
% Definicao das constantes para construcao do sinal de controlo u(t)
U1=1;
U2=1;
T=4;
alfa=2.5;
n1=100;
n2=100;

% Construcao do sinal
[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

figure();
plot(t,u);
grid on;
xlabel('t');
ylabel('u(t)');
title('Sinal');

%%
% Definicao das constantes para construcao do sinal de controlo u(t)
U1=1;
U2=2;
T=1;
alfa=0.5;
n1=100;
n2=100;

% Construcao do sinal
[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

figure();
plot(t,u);
grid on;
xlabel('t');
ylabel('u(t)');
title('Sinal');

%% 7.

clear all;
close all;
clc;

b=0;

% Caso de alfa=0.5 e beta=0.2
alfa=0.5;
beta=0.2;

% Calculo de T e U1 segundo as formulas determinadas teoricamente
T=sqrt(2*(1+beta)*(1+alfa)/alfa);
T1=T/(1+alfa);

U1=(2*(1+beta))/(((T1)^2)*(alfa+1));
U2=U1/alfa;

% Numero de pontos
n1=200;
n2=200;

[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

np=n1+n2-1;

step=T/np;

u_entrada.time=[t'];
u_entrada.signals.values=[u'];
u_entrada.signals.dimensions=[1];
sim('sim1',t);

tsim1=tsim;
y1=y;
yponto1=yponto;

%%
% Caso de alfa=1 e beta=0.2

alfa=1;
beta=0.2;

% Calculo de T e U1 segundo as formulas determinadas teoricamente
T=sqrt(2*(1+beta)*(1+alfa)/alfa);
T1=T/(1+alfa);

U1=(2*(1+beta))/(((T1)^2)*(alfa+1));
U2=U1/alfa;

[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

u_entrada.time=[t'];
u_entrada.signals.values=[u'];
u_entrada.signals.dimensions=[1];
sim('sim1',t);

tsim2=tsim;
y2=y;
yponto2=yponto;

%%
% Caso de alfa=1.3 e beta=0.4

alfa=1.3;
beta=0.4;

% Calculo de T e U1 segundo as formulas determinadas teoricamente
T=sqrt(2*(1+beta)*(1+alfa)/alfa);
T1=T/(1+alfa);

U1=(2*(1+beta))/(((T1)^2)*(alfa+1));
U2=U1/alfa;

[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

u_entrada.time=[t'];
u_entrada.signals.values=[u'];
u_entrada.signals.dimensions=[1];
sim('sim1',t);

tsim3=tsim;
y3=y;
yponto3=yponto;

%%
% Desenho dos graficos

% Evolucao da posicao
figure();
plot(tsim1,y1,'r');
grid on;
hold on;
xlabel('t');
ylabel('y(t)');
title('Posicao do braco');
plot(tsim2,y2,'m');
plot(tsim3,y3,'b');
hold off;
legend('alfa=0.5 e beta=0.2','alfa=1 e beta=0.2','alfa=1.3 e beta=0.4');

% Evolucao da velocidade
figure();
plot(tsim1, yponto1,'r');
grid on;
hold on;
xlabel('t');
ylabel('$$\dot{y} (t)$$','interpreter','latex');
title('Velocidade do braco');
plot(tsim2, yponto2,'m');
plot(tsim3, yponto3,'b');
hold off;
legend('alfa=0.5 e beta=0.2','alfa=1 e beta=0.2','alfa=1.3 e beta=0.4');

% Plano (posicao,velocidade)
figure();
plot(y1,yponto1,'r');
grid on;
hold on;
xlabel('y');
ylabel('$$\dot{y} (t)$$','interpreter','latex');
title('Plano (y, $$\dot{y}$$)','interpreter','latex');
plot(y2,yponto2,'m');
plot(y3,yponto3,'b');
hold off;
legend('alfa=0.5 e beta=0.2','alfa=1 e beta=0.2','alfa=1.3 e beta=0.4');

%%
% Versao perturbada

b=0.025;

% Caso de alfa=0.5 e beta=0.2
alfa=0.5;
beta=0.2;

% Calculo de T e U1 segundo as formulas determinadas teoricamente
T=sqrt(2*(1+beta)*(1+alfa)/alfa);
T1=T/(1+alfa);

U1=(2*(1+beta))/(((T1)^2)*(alfa+1));
U2=U1/alfa;

[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

np=n1+n2-1;

step=T/np;

u_entrada.time=[t'];
u_entrada.signals.values=[u'];
u_entrada.signals.dimensions=[1];

sim('sim1',t);

tsim1=tsim;
y1=y;
yponto1=yponto;

%%
% Caso de alfa=1 e beta=0.2

alfa=1;
beta=0.2;

% Calculo de T e U1 segundo as formulas determinadas teoricamente
T=sqrt(2*(1+beta)*(1+alfa)/alfa);
T1=T/(1+alfa);

U1=(2*(1+beta))/(((T1)^2)*(alfa+1));
U2=U1/alfa;

[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

u_entrada.time=[t'];
u_entrada.signals.values=[u'];
u_entrada.signals.dimensions=[1];
sim('sim1',t);

tsim2=tsim;
y2=y;
yponto2=yponto;

%%
% Caso de alfa=1.3 e beta=0.4

alfa=1.3;
beta=0.4;

% Calculo de T e U1 segundo as formulas determinadas teoricamente
T=sqrt(2*(1+beta)*(1+alfa)/alfa);
T1=T/(1+alfa);

U1=(2*(1+beta))/(((T1)^2)*(alfa+1));
U2=U1/alfa;

[u,t] = sinal( T, alfa, beta, U1, U2, n1, n2 );

u_entrada.time=[t'];
u_entrada.signals.values=[u'];
u_entrada.signals.dimensions=[1];

sim('sim1',t);

tsim3=tsim;
y3=y;
yponto3=yponto;

%%
% Desenho dos graficos

% Evolucao da posicao
figure();
plot(tsim1,y1,'r');
grid on;
hold on;
xlabel('t');
ylabel('y(t)');
title('Posicao do braco');
plot(tsim2,y2,'m');
plot(tsim3,y3,'b');
hold off;
legend('alfa=0.5 e beta=0.2','alfa=1 e beta=0.2','alfa=1.3 e beta=0.4');

% Evolucao da velocidade
figure();
plot(tsim1, yponto1,'r');
grid on;
hold on;
xlabel('t');
ylabel('$$\dot{y} (t)$$','interpreter','latex');
title('Velocidade do braco');
plot(tsim2, yponto2,'m');
plot(tsim3, yponto3,'b');
hold off;
legend('alfa=0.5 e beta=0.2','alfa=1 e beta=0.2','alfa=1.3 e beta=0.4');

% Plano (posicao,velocidade)
figure();
plot(y1,yponto1,'r');
grid on;
hold on;
xlabel('y');
ylabel('$$\dot{y} (t)$$','interpreter','latex');
title('Plano (y, $$\dot{y}$$)','interpreter','latex');
plot(y2,yponto2,'m');
plot(y3,yponto3,'b');
hold off;
legend('alfa=0.5 e beta=0.2','alfa=1 e beta=0.2','alfa=1.3 e beta=0.4');

%%
% Tal como previsto teoricamente, a situacao em que a cabeca se desloca mais rapidamente para o valor 0 corresponde ao caso em que temos $\alpha=1$.
% Verificamos que para valores de alfa e beta aleatorios obtiveram-se os valores finais desejados.
% Por outro lado, quando adicionamos um valor b diferente de zero, correspondente a existencia de atrito, verificamos que a cabeca nao se desloca exatamente para
% a posicao zero ficando ainda alguma distancia. Isto deve-se ao fato de estarmos a produzir uma tensao que leva a cabeca para zero sem atrito. No caso de b diferente
% de zero teriamos que ter em conta a forca aplicada necessaria para vencer a forca de atrito.

%% 8.

clear all;
close all;
clc;

% Grelha de pontos
y=[-1:0.05:1];
yponto=[-1:0.05:1];
count=length(yponto);

for i=1:1:count
	for j=1:1:count
		ut(i,j)=sign(sign(-y(i))*sqrt(2*abs(-y(i)))-yponto(j));		
	end
end

figure();
surf(y,yponto,ut);
view(-140, 34);
xlabel('yponto');
ylabel('y');
zlabel('u');


%%
% Este tipo de funcionamento tem um objetivo semelhante ao anterior, com a diferenca de u(t) ser gerado dinamicamente em funcao dos valores de posicao e velocidade
% em dado instante de tempo. Para cada par (y,v) e gerado um valor u de modo a que o sistema se comporte como desejado. 
%%
% No caso de b=0, a tensao u ira corresponder a aceleracao. Quando temos posicao positiva e velocidade positiva a tensao tera que ser negativa de modo 
% a colocar a velocidade negativa levando a cabeca para 0.
%%
% Quando a posicao e negativa e a velocidade negativa, u tera que ser positiva de modo a colocar a velocidade no sentido positivo levando a cabeca para zero.
%%
% Se a posicao for positiva e a velocidade negativa, quando os valores de posicao forem proximos de 1 a tensao vai ser negativa de modo a aumentar em modulo
% a velocidade negativa de modo a deslocar a cabeca mais rapidamente para zero, enquanto que para valores de posicao proximos de zero a tensao e 
% positiva diminuindo o modulo da velocidade negativa de modo a colocar a cabeca na posicao zero com velocidade nula. 
%%
% Se a posicao for negativa e a velocidade positiva acontece exatamente o referido na situacao anterior mas com valores simetricos.


%% 9.

clear all;
close all;
clc;

% Definicao de condicoes iniciais
yinicial=1;
ypinicial=0;

sim('sim9');

figure();
plot(tsim,y);
grid on;
xlabel('t');
ylabel('y');
title('Posicao');

figure();
plot(tsim,v);
grid on;
xlabel('t');
ylabel('v');
title('Velocidade');

figure();
plot(tsim,utensao);
grid on;
xlabel('t');
ylabel('u');
title('Tensao');

%%
% Em primeiro lugar, podemos verificar que esta estrategia permite chegar ao obejetivo pretendido (cabeca na posicao 0 com velocidade 0). Inclusive,
% esta metodologia leva a cabeca para a origem mais rapidamente que os outros metodos logo permite cumprir o objetivo com maior eficiencia. No entanto,
% se observarmos o sinal de controlo (u) verificamos que apos o sistema atingir o equilibrio (y=0 e v=0), o sinal de controlo comeca a oscilar rapidamente
% em torno de 0 entre -1 e 1. Este fenomeno consiste no denominado chattering, fenomeno este que sera prejudicial para o disco vai desgastar a cabeca do braco do disco.
% O ideal depois do equilibrio seria termos um sinal u constante e igual a 0. Este fenomeno deve-se aos pequenos ajustes que a cabeca faz em torno da origem
% fruto de o sistema ser realimentado. Em particular, o problema esta no declive elevado do ganho de saturacao junto a origem.

%% 10.

clear all;
close all;
clc;

% Definicao de constantes
yl=0.05;

k1=1/yl;
k2=sqrt(2*k1);

% Grelha de valores
y=[-1:0.02:1];
yponto=[-1:0.02:1];
count=length(yponto);

for i=1:1:count
	for j=1:1:count
		if(abs(y(i))<=yl)
			ut(i,j)=sign((k1/k2)*(-y(i))-yponto(j));
		end
		if(abs(y(i))>=yl)
			ut(i,j)=sign(sign(-y(i))*(sqrt(2*abs(-y(i)))-(1/k2))-yponto(j));
		end	
	end
end

figure();
surf(y,yponto,ut);
view(-140, 34);
xlabel('$$\dot{y} (t)$$','interpreter','latex');
ylabel('y');
zlabel('u');

%%
% De modo a ultrapassar o problema de chattering encontrado no sistema anterior, a funcao e que rege o sistema e agora alterada de modo a tornar o declive
% que antes era excessivamente elevado em algo mais "suave". Olhando para a superficie 3D que relaciona posicao, velociade e tensao contata-se que e praticamente
% igual a obtida na pergunta 8. No entanto, neste grafico 3D podemos ver uma transicao muito mais suave entre os valores -1 e 1 de u, o que indica uma maior
% linearidade em torno da origem que permite eliminar o chattering. Quanto maior for k1 mais suave sera o sistema.

%% 11.

clear all;
close all;
clc;

% Definicao de constantes 
yl=0.05;

k1=1/yl;
k2=sqrt(2*k1);

sim('sim11a');

figure();
plot(tsim,y);
grid on;
xlabel('t');
ylabel('y');
title('Posicao');

figure();
plot(tsim,v);
grid on;
xlabel('t');
ylabel('v');
title('Velocidade');

figure();
plot(tsim,utensao);
grid on;
xlabel('t');
ylabel('u');
title('Tensao');

%%
% Fazendo o ganho anterior igual a k2 e mudando a funcao utilizada no sistema conseguimos eliminar o efeito de chattering. Com este novo metodo, apos a velocidade
% e posicao chegarem a zero, a tensao u vai-se aproximando tambem de zero deixando de ter o efeito oscilante do anterior metodo. No entanto, apesar de termos corrigido
% este efeito o sistema torna-se mais lento sendo que a posicao chega a zero em aproximadamente 3 segundos ao contrario do anterior metodo em que demorava menos de
% 2 segundos. A degradacao no tempo sera 2.967-1.929=1.038s.

%%
% Utilizando apenas o ramo (k1/k2)*x

sim('sim11b');

figure();
plot(tsim,y);
grid on;
xlabel('t');
ylabel('y');
title('Posicao');

figure();
plot(tsim,v);
grid on;
xlabel('t');
ylabel('v');
title('Velocidade');

figure();
plot(tsim,utensao);
grid on;
xlabel('t');
ylabel('u');
title('Tensao');

%%
% Usando apenas o primeiro ramo da funcao todos os tres parametros tendem para zero (nao ha efeito de chattering) mas para alem de serem mais lentos a convergir
% para zero a posicao e a velocidade oscilam um pouco em torno de zero ate que convirjam para este valor.

%% 12.

clear all;
close all;
clc;

% Metodo 1

% Definicao de condicoes iniciais
yinicial=1;
ypinicial=0;
b=0.025;

sim('sim12a');

figure();
plot(tsim,y);
grid on;
xlabel('t');
ylabel('y');
title('Posicao');

figure();
plot(tsim,v);
grid on;
xlabel('t');
ylabel('v');
title('Velocidade');

figure();
plot(tsim,utensao);
grid on;
xlabel('t');
ylabel('u');
title('Tensao');

%%
% Metodo 2

% Definicao de constantes 
yl=0.05;

k1=1/yl;
k2=sqrt(2*k1);

sim('sim12b');

figure();
plot(tsim,y);
grid on;
xlabel('t');
ylabel('y');
title('Posicao');

figure();
plot(tsim,v);
grid on;
xlabel('t');
ylabel('v');
title('Velocidade');

figure();
plot(tsim,utensao);
grid on;
xlabel('t');
ylabel('u');
title('Tensao');

%%
% Dado a estarmos perante um sistema em cadeia fechada, as perturbacoes causadas pelo atrito nao tem influencia no resulatdo final. Adicionando b
% obtemos as mesmas respostas que obtivemos com b=0

%% 13.

% Definicao de constantes
b=0;
yl=0.05;
k1=1/yl;
k2=sqrt(2*k1);

% Referencia de sinais rampa
figure();
sim('sim13');
plot(tsim, y, tsim, referencia,'LineWidth', 1);
xlabel('Tempo');
ylabel('Posicao y');
title('Posicao y para o sinal de referencia composto por rampas');
legend('Posicao y','Referencia');

% Referencia de sinais constantes
figure();
sim('sim13b');
plot(tsim, y, tsim, referencia,'LineWidth', 1);
xlabel('Tempo');
ylabel('Posicao y');
title('Posicao y para o sinal de referencia composta por degraus');
legend('Posicao y','Referencia');

%%
% Espera-se que alterando o valor de referencia, o sistema tambem tenda para esse valor. Analisando os graficos consegue
% se ver que a posicao do braco segue o valor de referencia apenas com um atraso no tempo, o mesmo iria acontecer com um 
% sinal de referencia composta por degraus mas por impossibilidade fisica a posicao nao pode ter descontinuidades espaciais,
% portanto a posicao y vai ajustar-se ao longo do tempo para o novo valor de referencia
##### SOURCE END #####
--></body></html>